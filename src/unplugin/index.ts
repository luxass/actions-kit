import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import process from "node:process";
import YAML from "js-yaml";
import { createUnplugin, type UnpluginFactory, type UnpluginInstance } from "unplugin";

export interface ActionsKitOptions {
  /**
   * The path to the action.yml or action.yaml file.
   * If not provided, it will look for action.yml or action.yaml in the root directory.
   */
  actionPath?: string;

  /**
   * Inject "inputs" as global variables.
   */
  injectInputs?: boolean;

  /**
   * The output path for the generated typescript file.
   * If not provided, it will use the directory where the action.yml or action.yaml file is located.
   */
  outputPath?: string;
}

/**
 * A unplugin factory, used by Unplugin to create a new plugin instance.
 */
export const unpluginFactory: UnpluginFactory<ActionsKitOptions | undefined> = (options = {}) => {
  let entryPoint: string | undefined;
  let globalInputs: Record<string, string> | undefined;
  return {
    name: "unplugin-actions-kit",
    enforce: "pre",
    resolveId(id, _, options) {
      if (options.isEntry) {
        entryPoint = id;
      }
      return null;
    },
    transformInclude(id) {
      if (entryPoint == null) {
        throw new Error("entryPoint is not set");
      }

      if (!join(process.cwd(), entryPoint).endsWith(id)) {
        return false;
      }

      return true;
    },
    transform(code, id) {
      if (entryPoint == null) {
        throw new Error("entryPoint is not set");
      }

      if (id.startsWith("./")) {
        // remove the "./" prefix
        id = id.slice(2);
      }

      if (!join(process.cwd(), entryPoint).endsWith(id)) {
        return;
      }

      if (options.injectInputs) {
        return `globalThis.ACTION_INPUTS = ${JSON.stringify(globalInputs, null, 2)};\n${code};`;
      }

      return code;
    },
    buildStart() {
      if (options.actionPath == null) {
        // check if either action.yml or action.yaml exists
        const actionYmlPath = join(import.meta.dirname, "action.yml");
        const actionYamlPath = join(import.meta.dirname, "action.yaml");

        // eslint-disable-next-line no-console
        console.log({
          actionYmlPath,
          actionYamlPath,
        });

        if (existsSync(actionYmlPath)) {
          options.actionPath = actionYmlPath;
        } else if (existsSync(actionYamlPath)) {
          options.actionPath = actionYamlPath;
        } else {
          throw new Error("action.yml or action.yaml is required");
        }
      }

      // read the file
      const yaml = YAML.load(readFileSync(options.actionPath, "utf8"));

      if (yaml == null) {
        throw new Error("action.yml or action.yaml is empty");
      }

      if (typeof yaml !== "object") {
        throw new TypeError("action.yml or action.yaml is not an object");
      }

      if (!("inputs" in yaml) || typeof yaml.inputs !== "object" || yaml.inputs == null) {
        throw new TypeError("action.yml or action.yaml does not have inputs");
      }

      const inputsObject = Object.fromEntries(
        Object.entries(yaml.inputs).map(([name]) => [name, name]),
      );

      globalInputs = inputsObject;

      const outputPath = options.outputPath == null ? dirname(options.actionPath) : options.outputPath;

      writeFileSync(join(outputPath, "actions-kit.d.ts"), /* typescript */`// generated by 'actions-kit'
        import "@actions/core";

        ${!options.injectInputs
          ? ""
          : /* typescript */`
declare global {
  export const ACTION_INPUTS: ${JSON.stringify(inputsObject, null, 2)};
}`}

declare module "@actions/core" {

  type InputNames = ${Object.keys(yaml.inputs).map((name) => JSON.stringify(name)).join(" | ")};

  export function getInput(name: InputNames, options?: InputOptions): string;
}
`);
    },
  };
};

/**
 * The main unplugin instance.
 */
export const unplugin: UnpluginInstance<ActionsKitOptions | undefined, boolean> = /* #__PURE__ */ createUnplugin(unpluginFactory);

export default unplugin;
